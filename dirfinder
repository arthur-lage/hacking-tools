#!/usr/bin/env python3

import requests
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin
import time
import sys

class Color:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    END = '\033[0m'

def print_status(message, color=None, verbose_only=False, args=None):
    """Helper function for colored and conditional printing"""
    if verbose_only and not (args and args.verbose):
        return
    if color:
        print(f"{color}{message}{Color.END}")
    else:
        print(message)

def check_path(dir_path, base_url, headers, args, success_count_lock, success_count):
    """Check if a directory path exists on the target server"""
    try:
        target_url = urljoin(base_url + '/', dir_path)
        
        response = requests.get(
            target_url,
            headers=headers,
            timeout=args.timeout,
            allow_redirects=args.follow_redirects
        )

        if response.status_code != 404:
            with success_count_lock:
                success_count[0] += 1
            
            status_color = Color.GREEN if response.status_code < 400 else Color.YELLOW
            print_status(f"{response.status_code:>3}  {target_url}", status_color)
            
            if args.output_file:
                with open(args.output_file, 'a') as f:
                    f.write(f"{response.status_code} {target_url}\n")
                    
        elif args.verbose:
            print_status(f"Testing: {target_url} => {response.status_code}", verbose_only=True, args=args)

    except requests.exceptions.RequestException as e:
        if args.verbose:
            print_status(f"Error testing {dir_path}: {str(e)}", Color.RED, verbose_only=True, args=args)
    except Exception as e:
        print_status(f"Unexpected error: {str(e)}", Color.RED)
    
    return None

def main():
    parser = argparse.ArgumentParser(
        description="Advanced directory brute-forcing tool",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    parser.add_argument('-u', '--url', required=True, 
                        help="Target URL (include http:// or https://)")
    parser.add_argument('-w', '--wordlist', required=True,
                        help="Path to wordlist file")
    

    parser.add_argument('-t', '--threads', type=int, default=20,
                        help="Number of threads to use")
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Enable verbose output")
    parser.add_argument('-o', '--output-file',
                        help="File to save successful results")
    parser.add_argument('--timeout', type=int, default=3,
                        help="Request timeout in seconds")
    parser.add_argument('--follow-redirects', action='store_true',
                        help="Follow HTTP redirects")
    
    args = parser.parse_args()

    # Input validation
    if not args.url.startswith(('http://', 'https://')):
        print_status("Error: URL must start with http:// or https://", Color.RED)
        sys.exit(1)

    try:
        with open(args.wordlist) as f:
            words = [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        print_status(f"Error: Wordlist file not found: {args.wordlist}", Color.RED)
        sys.exit(1)
    except Exception as e:
        print_status(f"Error reading wordlist: {str(e)}", Color.RED)
        sys.exit(1)

    # Prepare headers
    headers = {
        'User-Agent': 'AdvancedDirFinder/1.0',
        'Accept': '*/*',
        'Connection': 'keep-alive'
    }

    print_status(f"\nStarting directory brute-force on {args.url}", Color.YELLOW)
    print_status(f"Wordlist: {args.wordlist} ({len(words)} entries)")
    print_status(f"Threads: {args.threads}")
    print_status(f"Timeout: {args.timeout}s\n")

    start_time = time.time()
    success_count = [0]
    success_count_lock = threading.Lock()

    try:
        with ThreadPoolExecutor(max_workers=args.threads) as executor:
            futures = [
                executor.submit(
                    check_path, 
                    word, 
                    args.url, 
                    headers, 
                    args, 
                    success_count_lock,
                    success_count
                ) 
                for word in words
            ]
            
            for _ in as_completed(futures):
                pass
                
    except KeyboardInterrupt:
        print_status("\n[!] Received keyboard interrupt. Shutting down...", Color.RED)
        executor.shutdown(wait=False)
        sys.exit(1)

    elapsed_time = time.time() - start_time
    print_status(f"\nScan completed in {elapsed_time:.2f} seconds", Color.YELLOW)
    print_status(f"Tested: {len(words)} paths")
    print_status(f"Found: {success_count[0]} accessible paths", 
                Color.GREEN if success_count[0] > 0 else Color.END)

if __name__ == "__main__":
    import threading
    main()